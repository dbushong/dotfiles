#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;
use File::Basename;

my %format = (
  'perl-script' => {
    extension  => 'pl',
    executable => 1,
    template   => <<'EOT'
#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use utf8;

my $prog = basename($0);
my %opt;
getopts('h', \%opt);
usage() if $opt{h};
sub usage {
  die <<EOU;
usage: $prog
EOU
}

EOT
  },
  'xhtml' => {
    extension    => 'html',
    editor_flags => { qr/vi/ => ['+8'] },
    template => <<'EOT'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>Title of Page</title>
  </head>
  <body>
    
  </body>
</html>
EOT
  },
  'php' => {
    extension    => 'php',
    editor_flags => { qr/vi/ => ['+2'] },
    template     => "<?\n\n?>\n",
  },
  'manifest.json' => {
    editor_flags => { qr/vi/ => ['+3'] },
    template     => <<'EOT'
{
  // Required
  "name":    "My Extension",
  "version": "versionString",

  // Recommended
  "description": "A plain text description",
  "icons": { 
    "16":  "icon16.png",
    "32":  "icon32.png",
    "48":  "icon48.png",
    "128": "icon128.png"
  },

  // Pick one (or none)
  "brower_action": {...},
  "page_action": {...},
  "theme": {...},

  // Add any of these that you need
  "background_page": "aFile.html",
  "chrome_url_overrides": {...},
  "content_scripts": [...],
  "options_page": "aFile.html",
  "permissions": [...],
  "plugins": [...],
  "update_url": "http://path/to/updateInfo.xml"
}
EOT
  },
  recipe => {
    template => sub {
      my $name = $file;
      $name =~ s/\.txt$//;
      $name =~ s/-(.)/ \u$1/g;
      $name = ucfirst($name);
      my $line = $name;
      $line =~ s/./~/g;
      return <<EOT;
$name
$line


EOT
    }
  }
);

my $prog = basename($0);
my %opt;
getopts('hf', \%opt);
usage() if $opt{h} || @ARGV < 1 || @ARGV > 2;
sub usage {
  die <<EOU;
usage: $prog [-f] [@{[ join(' | ', sort keys %format) ]}] filename
       -f: force (file file already exists)
EOU
}

my ($key, $file);
if (@ARGV == 1) {
  $key = basename($file = $ARGV[0]);
  unless ($format{$key}) {
    die "$prog: file must have an extension to autodetect format\n"
      unless $file =~ /\.([^.]+)$/;
    my $ext = lc($1);
    ($key) = grep { lc($format{$_}{extension} || '') eq $ext } keys %format;
    die "$prog: no match for format with given extension; specify explicitly\n"
      unless $key;
  }
}
else {
  ($key, $file) = @ARGV;
}

unless ($format{$key}) {
  my @m = grep(/$key/i, sort { length($a) <=> length($b) } keys %format);
  die("$prog: choose one of: " . join(', ', @m) . "\n") if @m > 1;
  die "$prog: no match for format $key\n" unless @m;
  $key = $m[0];
}

my $fmt = $format{$key};

die "$prog: $file already exists; -f to force\n";

open(my $fh, '>', $file) || die "$prog: couldn't open $file: $!\n";
print $fh $fmt->{template};
close($fh);

chmod(0775, $file) if $fmt->{executable};

my $editor = $ENV{VISUAL} || $ENV{EDITOR} || 'editor';
my @flags;
$fmt->{editor_flags} ||= { qr/vi/ => ['+'] };
while (my ($re, $flags) = each(%{$fmt->{editor_flags}})) {
  if ($editor =~ $re) {
    @flags = @$flags;
    last;
  }
}
exec($editor, @flags, $file);
