#!/usr/bin/perl
#
# mount.restfs: mounts a "web filesystem" using fuse
#
# assuming mount on /mnt, paths look like:
#
# /mnt/<encoded url>/<info>
#
# where <encoded url> is a url with , replaced with %2C then / replaced with ,
# so, e.g. /mnt/http:,,en.wikipedia.org,w,api.php?action=parse&page=Kittens
# (shell escaping is left as an exercise to the reader)
#
# <info> consists of the following shared files:
# content: result of the request
# url: decoded url of the request for convenience
# headers: response headers
# additionally, types text/plain and text/html have:
# links/: a directory of symlinks named (uniquely) after their related text
# additionally, types text/html, text/xml, and application/json have:
# 
# /mnt/<encoded-url>/tree/<tree-path>
#
# <tree-path> varies depending on the encoding, but for JSON each path
# component corresponds to an object property (numbers for array indices),
# and for html & xml it corresponds to an XPath
#
# TODO: threading!

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use Fuse;
use POSIX qw(:errno_h :fcntl_h ceil);
use LWP::UserAgent;
use URI;
use JSON;
use HTML::TreeBuilder;
use XML::XPath;
use Digest::MD5 'md5_base64';
use Encode;
use List::Util 'first';

my $prog = basename($0);
my %opt;
getopts('hv', \%opt);
usage() if $opt{h} || @ARGV != 1;
sub usage {
  die <<EOU;
usage: $prog [-v] mount-point
       -v: verbose
EOU
}

my $prev_path;
my $JSON = JSON->new->allow_nonref(1);
my $ua = LWP::UserAgent->new(agent => 'Firefox'); # TODO: add sexy useragent
my %hcache; # TODO: replace with Tie::Cache::LRU or equiv.
my %ocache; # TODO: replace with Tie::Cache::LRU or equiv.
my $mount = $ARGV[0]; $mount =~ s,/+$,,;
die "No such directory $mount\n" unless -d $mount;

my %mime_map = (
  'text/javascript' => 'application/json',
  'text/json'       => 'application/json',
  'application/xml' => 'text/xml',
  'text/xhtml'      => 'text/html',
);

my %handlers = (
  # links handlers take content and return a hash of name => links
  # names must (obviously) be unique, and links may be relative strings
  links => {
    qr{^text/plain$}i => \&find_text_links,
    qr{html$}i        => \&find_html_links
  },
  # tree handlers take content and path parts and return a valid info hashref
  # or undef
  tree => {
    qr{json$}i => \&build_json_tree,
    qr{xml$}   => \&build_xml_tree,
    qr{html$}  => \&build_html_tree,
  },
);

Fuse::main(
  mountpoint   => $mount,
  debug        => 0,
  threaded     => 0,
  'getattr'    => \&rfs_getattr,
  'readlink'   => \&rfs_readlink,
  'getdir'     => \&rfs_getdir,
  'open'       => \&rfs_open,
  'read'       => \&rfs_read,
);

sub rfs_getattr {
  #print "getattr()\n" if $opt{v};
  my $info    = parse_path(@_) || return -ENOENT();
  my $mtime   = $info->{mtime} || time();
  my $size    = $info->{file} ? length($info->{file}) : 0;
  my $blksize = 1024 * 1024;
  my $blocks  = ceil($size / $blksize);
  my $type;
  if ($info->{dir}) {
    $type = 0040; 
  }
  elsif ($info->{link_to}) {
    $type = 0120;
  }
  elsif (exists $info->{file}) {
    $type = 0100;
  }
  else {
    warn "unknown reponse from parse_path()\n";
    return -ENOENT();
  }
  my $mode = 0444 + ($type << 9); # world-readable + type of file
  (0, 0, $mode, 1, 0, 0, 0, $size, time(), $mtime, $mtime, $blksize, $blocks);
}

sub rfs_readlink {
  #print "readlink()\n" if $opt{v};
  my $info = parse_path(@_);
  $info && $info->{link_to};
}

sub rfs_getdir {
  #print "getdir()\n" if $opt{v};
  my $info = parse_path(@_) || return -ENOENT();
  return -ENOTDIR() unless $info->{dir};
  ('.', '..', @{$info->{dir}}, 0);
}

sub rfs_open {
  #print "open()\n" if $opt{v};
  my ($path, $flags) = @_;
  my $info = parse_path($path);
  # TODO: check flags
  return 0 if $info && !$info->{dir};
  return -EACCES();
}

sub rfs_read {
  #print "read()\n" if $opt{v};
  my ($path, $bytes, $off) = @_;
  my $info = parse_path($path) || return -ENOENT();
  substr($info->{file}, $off, $bytes);
}

sub parse_path {
  my ($path) = @_;
  $path =~ s{(?<=[^/])/+$}{}; # trim off trailing /s

  #print "PATH $path\n" 
  #  if $opt{v} && !(defined $prev_path && $path eq $prev_path);
  #$prev_path = $path;

  # top level dir: show our cached urls (handy)
  return { dir => [map { encode_name($_) } keys %hcache] } if $path eq '/';

  # not a url at top-level?  bogus!
  $path =~ m{^/(https?:,,[^/]+)/?} || return undef;

  # decode url and grab rest of path
  my $url = decode_name($1);
  $path   = $';

  my $res     = fetch_cached($url, $path eq 'content');
  my $mtime   = $res->last_modified || time();
  my $content = $res->decoded_content;
  my $type    = $res->header('Content-type');
  $type =~ s/\s*;.*//;

  if ($path eq '') {
    my @kids = qw(headers content url);  # shared virtual files/dirs
    push(@kids, 'links') if handler_for('links', $type);
    push(@kids, 'tree')  if handler_for('tree',  $type);
    return { dir => \@kids, mtime => $mtime };
  }
  elsif ($path eq 'content') {
    return { file => $content, mtime => $mtime };
  }
  elsif ($path eq 'url') {
    return { file => $url, mtime => $mtime };
  }
  elsif ($path =~ m{^headers(?:/([^/]+))?$}) {
    my $which = $1;
    if ($which) {
      return { 
        file  => scalar($res->header(decode_name($which))), 
        mtime => $mtime 
      };
    }
    else {
      return { dir => [ 
        map { encode_name($_) } $res->header_field_names
      ], mtime => $mtime };
    }
  }
  elsif ($path =~ m{^links(?:/([^/]+))?$}) {
    my $which   = $1;
    my $handler = handler_for('links', $type) || return undef;
    my %links   = $handler->($content);
    if ($which) {
      my $lto = link_to($links{decode_name($which)}, $url) || return undef;
      return { link_to => $lto, mtime => $mtime };
    }
    else {
      return { dir => [ map { encode_name($_) } grep {
        link_to($links{$_}, $url)
      } keys %links ], mtime => $mtime };
    }
  }
  elsif ($path =~ m{^tree(?:/(.+))?$}) {
    my @parts      = map { decode_name($_) } split(/\//, $1 || '');
    my $handler    = handler_for('tree', $type) || return undef;
    my $info       = $handler->($content, $url, @parts) || return undef;
    $info->{mtime} = $mtime;
    return $info;
  }
}

sub decode_name {
  my ($str) = @_;
  $str =~ s#,#/#g;
  $str =~ s/\%2C/,/ig;
  $str;
}

sub encode_name {
  my ($url) = @_;
  $url =~ s/,/\%2C/g;
  $url =~ s#/#,#g;
  $url;
}

sub fetch_cached {
  my ($url, $force) = @_;

  unless ($force) {
    my $res = $hcache{$url};
    return $res if $res;
  }

  print "GET $url\n";
  $hcache{$url} = $ua->get($url);
}

sub find_text_links {
  my ($content) = @_;
  my @urls = sort ($content =~ m{\bhttp://[^\s"'<>]+}g);
  return map { 'untitled'.($_+1) => $urls[$_] } 0..$#urls;
}

sub find_html_links {
  my ($html) = @_;

  my $obj = parse_xml(html2xml($html));
  my %links;
  for my $a ($obj->findnodes('//a[@href]')) {
    my $name = $a->string_value;
    $name =~ s/^\s+|\s+$//g;
    $name = 'untitled' unless length $name;
    my ($base, $n);
    for ($base = $name, $n = 2; exists $links{$name}; $name = $base . $n++) {}
    $links{$name} = $a->getAttribute('href');
  }
  return %links;
}

sub link_to {
  my ($str, $base) = @_;
  $str = URI->new_abs($str, $base) if $base;
  return undef unless $str =~ m{^https?://\S+$};
  return $mount . '/' . encode_name($str);
}

sub file_or_link_to {
  my ($str, $base) = @_;
  my $lto = link_to($str, $base);
  return { link_to => $lto } if $lto;
  return { file    => $str };
}

sub parse_xml {
  my ($xml) = @_;
  eval { ocache($xml, sub { XML::XPath->new(xml => $_[0]) }) };
}

sub html2xml {
  my ($html) = @_;
  ocache($html, sub { HTML::TreeBuilder->new_from_content($_[0])->as_XML });
}

sub ocache {
  my ($tree, $gen) = @_;
  $ocache{md5_base64(encode('utf-8', $tree))} ||= $gen->($tree);
}

sub handler_for {
  my ($thing, $type) = @_;
  my $key = (first { $type =~ $_ } keys(%{$handlers{$thing}})) || return undef;
  $handlers{$thing}{$key};
}

sub build_html_tree {
  my ($html, $url, @parts) = @_;
  build_xml_tree(html2xml($html), $url, @parts);
}

sub build_json_tree {
  my ($json, $url, @parts) = @_;

  my $tree = eval { ocache($json, sub { $JSON->decode($_[0]) }) } 
    || return undef;
  for (@parts) {
    if (ref($tree) eq 'HASH') {
      $tree = $tree->{$_};
    }
    elsif (ref($tree) eq 'ARRAY') {
      $tree = $tree->[$_];
    }
    else {
      return undef;
    }
  }
  if (ref($tree) eq 'HASH') {
    return { dir => [ map { encode_name($_) } keys %$tree ] };
  }
  elsif (ref($tree) eq 'ARRAY') {
    return { dir => [ 0..$#$tree ] };
  }
  else {
    my $str = $JSON->encode($tree);
    $str =~ s/^"|"$//g;
    return file_or_link_to($str);
  }
}

sub build_xml_tree {
  my ($xml, $url, @parts) = @_;

  my $path = '/' . join('/', @parts);
  my $xp = parse_xml($xml) || return undef;
  my $ns = eval { $xp->find($path) };
  return undef unless $ns && $ns->size;
  my $node = $ns->get_node(1);
  if ($node->isa('XML::XPath::Node::Element')) {
    my (%kids, %count);
    for my $kid ($node->getChildNodes()) {
      if (my $name = $kid->getName) {
        if ($count{$name}++) {
          if ($count{$name} == 2) {
            $kids{$name.'[1]'} = 1;
            delete $kids{$name};
          }
          $kids{$name.'['.$count{$name}.']'} = 1;
        }
        else {
          $kids{$name} = 1;
        }
      }
      else {
        $kids{'text()'} = 1;
      }
    }
    return { dir => [ map { encode_name($_) } 
      keys(%kids),
      map { '@' . $_->getName } $node->getAttributes()
    ]};
  }
  elsif ($node->isa('XML::XPath::Node::Attribute')) {
    return file_or_link_to($node->getNodeValue,
      ($node->getName =~ /^(href|src)$/i) && $url);
  }
  elsif ($node->isa('XML::XPath::Node::Text')) {
    return file_or_link_to($node->getValue);
  }
  else {
    return undef;
  }
}
