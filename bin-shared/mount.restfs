#!/usr/bin/perl
#
# mount.restfs: mounts a "web filesystem" using fuse
#
# assuming mount on /mnt, paths look like:
#
# /mnt/<encoded url>/<info>
#
# where <encoded url> is a url with _ replaced with %5F then / replaced with _
# so, e.g. /mnt/http:__en.wikipedia.org_w_api.php?action=parse&page=Kittens
# (shell escaping is your problem)
#
# <info> consists of the following shared files:
# content: result of the request
# url: decoded url of the request for convenience
# headers: response headers
# additionally, types text/plain and text/html have:
# links/: a directory of symlinks named (uniquely) after their related text
# additionally, types text/html, text/xml, and application/json have:
# 
# /mnt/<encoded-url>/tree/<tree-path>
#
# <tree-path> varies depending on the encoding, but for JSON each path
# component corresponds to an object property (numbers for array indices)
#
# TODO: threading!

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use Fuse;
use POSIX qw(:errno_h :fcntl_h ceil);
use LWP::UserAgent;
use URI;
use JSON;
use HTML::TreeBuilder;
use XML::XPath;
use Digest::MD5 'md5_base64';
use Encode;

my $prog = basename($0);
my %opt;
getopts('hv', \%opt);
usage() if $opt{h} || @ARGV != 1;
sub usage {
  die <<EOU;
usage: $prog [-v] mount-point
       -v: verbose
EOU
}

my $prev_path;
my $JSON = JSON->new->allow_nonref(1);
my $ua = LWP::UserAgent->new(agent => 'Firefox'); # TODO: add sexy useragent
my %hcache; # TODO: replace with Tie::Cache::LRU or equiv.
my %ocache; # TODO: replace with Tie::Cache::LRU or equiv.
my $mount = $ARGV[0]; $mount =~ s,/+$,,;
die "No such directory $mount\n" unless -d $mount;

my %mime_map = (
  'text/javascript' => 'application/json',
  'text/json'       => 'application/json',
  'application/xml' => 'text/xml',
  'text/xhtml'      => 'text/html',
);

Fuse::main(
  mountpoint   => $mount,
  debug        => 0,
  threaded     => 0,
  'getattr'    => \&rfs_getattr,
  'readlink'   => \&rfs_readlink,
  'getdir'     => \&rfs_getdir,
  'open'       => \&rfs_open,
  'read'       => \&rfs_read,
);

sub rfs_getattr {
  print "getattr()\n" if $opt{v};
  my $info    = parse_path(@_) || return -ENOENT();
  my $mtime   = $info->{mtime} || time();
  my $size    = $info->{file} ? length($info->{file}) : 0;
  my $blksize = 1024;
  my $blocks  = ceil($size / $blksize);
  my $mode;
  if ($info->{dir}) {
    $mode = 0040; 
  }
  elsif ($info->{link_to}) {
    $mode = 0120;
  }
  else {
    $mode = 0100;
  }
  $mode = ($mode << 9) + 0444;
  (0, 0, $mode, 1, 0, 0, 0, $size, time(), $mtime, $mtime, $blksize, $blocks);
}

sub rfs_readlink {
  print "readlink()\n" if $opt{v};
  my $info = parse_path(@_);
  $info && $info->{link_to};
}

sub rfs_getdir {
  print "getdir()\n" if $opt{v};
  my $info = parse_path(@_) || return -ENOENT();
  return -ENOTDIR() unless $info->{dir};
  ('.', '..', @{$info->{dir}}, 0);
}

sub rfs_open {
  print "open()\n" if $opt{v};
  my ($path, $flags) = @_;
  my $info = parse_path($path);
  # TODO: check flags
  return 0 if $info && !$info->{dir};
  return -EACCES();
}

sub rfs_read {
  print "read()\n" if $opt{v};
  my ($path, $bytes, $off) = @_;
  my $info = parse_path($path) || return -ENOENT();
  substr($info->{file}, $off, $bytes);
}

sub parse_path {
  my ($path) = @_;
  $path =~ s{(?<=[^/])/+$}{}; # trim off trailing /s

  print "PATH $path\n" 
    if $opt{v} && !(defined $prev_path && $path eq $prev_path);
  $prev_path = $path;

  # top level dir: show our cached urls (handy)
  return { dir => [map { encode_name($_) } keys %hcache] } if $path eq '/';

  # not a url at top-level?  bogus!
  $path =~ m{^/(https?:__[^/]+)/?} || return undef;

  # decode url and grab rest of path
  my $url = decode_name($1);
  $path   = $';

  my $res   = fetch_cached($url, $path eq 'content');
  my $mtime = $res->last_modified || time();
  my $type  = $res->header('Content-type');
  $type =~ s/\s*;.*//;
  $type = $mime_map{$type} || $type;
  my $raw  = $res->decoded_content;

  if ($path eq '') {
    my @kids = qw(headers content url);
    push(@kids, 'links') if $type eq 'text/html' || $type eq 'text/plain';
    push(@kids, 'tree')  if $type =~ m{^(text/(ht|x)ml|application/json)$};
    return { dir => \@kids, mtime => $mtime };
  }
  elsif ($path eq 'content') {
    return { file => $raw, mtime => $mtime };
  }
  elsif ($path eq 'url') {
    return { file => $url, mtime => $mtime };
  }
  elsif ($path =~ m{^headers(?:/([^/]+))?$}) {
    my $which = $1;
    if ($which) {
      return { 
        file  => scalar($res->header(decode_name($which))), 
        mtime => $mtime 
      };
    }
    else {
      return { dir => [ 
        map { encode_name($_) } $res->header_field_names
      ], mtime => $mtime };
    }
  }
  elsif ($path =~ m{^links(?:/([^/]+))?$}) {
    my $which = $1;
    my %links = find_links($type, $raw);
    if ($which) {
      my $lto = link_to($links{decode_name($which)}, $url) || return undef;
      return { link_to => $lto, mtime => $mtime };
    }
    else {
      return { dir => [ map { encode_name($_) } keys %links ], mtime => $mtime };
    }
  }
  elsif ($path =~ m{^tree(?:/(.+))?$}) {
    my @parts = map { decode_name($_) } split(/\//, $1 || '');
    if ($type eq 'application/json') {
      my $tree = parse_json($raw);
      for (@parts) {
        if (ref($tree) eq 'HASH') {
          $tree = $tree->{$_};
        }
        elsif (ref($tree) eq 'ARRAY') {
          $tree = $tree->[$_];
        }
        else {
          return undef;
        }
      }
      if (ref($tree) eq 'HASH') {
        return { dir => [ map { encode_name($_) } keys %$tree ], mtime=>$mtime };
      }
      elsif (ref($tree) eq 'ARRAY') {
        return { dir => [ 0..$#$tree ], mtime => $mtime };
      }
      else {
        my $str = $JSON->encode($tree);
        $str =~ s/^"|"$//g;
        return file_or_link_to($str, $mtime);
      }
    }
    elsif ($type =~ m{^text/(html|xml)$}) {
      $path = '/' . join('/', @parts);
      my $xp = (($type =~ /html/) ? parse_html($raw) : parse_xml($raw))
        || return undef;
      my $ns = eval { $xp->find($path) };
      return undef unless $ns && $ns->size;
      my $node = $ns->get_node(1);
      if ($node->isa('XML::XPath::Node::Element')) {
        my (%kids, %count);
        for my $kid ($node->getChildNodes()) {
          if (my $name = $kid->getName) {
            if ($count{$name}++) {
              if ($count{$name} == 2) {
                $kids{$name.'[1]'} = 1;
                delete $kids{$name};
              }
              $kids{$name.'['.$count{$name}.']'} = 1;
            }
            else {
              $kids{$name} = 1;
            }
          }
          else {
            $kids{'text()'} = 1;
          }
        }
        return { dir => [ map { encode_name($_) } 
          keys(%kids),
          map { '@' . $_->getName } $node->getAttributes()
        ], mtime => $mtime};
      }
      elsif ($node->isa('XML::XPath::Node::Attribute')) {
        return file_or_link_to($node->getNodeValue, $mtime,
          ($node->getName =~ /^(href|src)$/i) && $url);
      }
      elsif ($node->isa('XML::XPath::Node::Text')) {
        return file_or_link_to($node->getValue, $mtime);
      }
      else {
        return undef;
      }
    }
  }
}

sub decode_name {
  my ($str) = @_;
  $str =~ s,_,/,g;
  $str =~ s/\%5f/_/ig;
  $str;
}

sub encode_name {
  my ($url) = @_;
  $url =~ s/_/\%5f/g;
  $url =~ s,/,_,g;
  $url;
}

sub fetch_cached {
  my ($url, $force) = @_;

  unless ($force) {
    my $res = $hcache{$url};
    return $res if $res;
  }

  $hcache{$url} = $ua->get($url);
}

sub find_links {
  my ($type, $raw) = @_;
  if ($type eq 'text/plain') {
    my @urls = sort ($raw =~ m{\bhttp://[^\s"'<>]+}g);
    return map { 'untitled'.($_+1) => $urls[$_] } 0..$#urls;
  }
  elsif ($type eq 'text/html') {
    my $obj = parse_html($raw);
    my %links;
    for my $a ($obj->findnodes('//a[@href]')) {
      my $name = $a->string_value;
      $name =~ s/^\s+|\s+$//g;
      $name = 'untitled' unless length $name;
      my ($base, $n);
      for ($base = $name, $n = 2; exists $links{$name}; $name = $base . $n++) {}
      $links{$name} = $a->getAttribute('href');
    }
    return %links;
  }
}

sub link_to {
  my ($str, $base) = @_;
  $str = URI->new_abs($str, $base) if $base;
  return undef unless $str =~ m{^https?://\S+$};
  return $mount . '/' . encode_name($str);
}

sub file_or_link_to {
  my ($str, $mtime, $base) = @_;
  my $lto = link_to($str, $base);
  return { link_to => $lto, mtime => $mtime } if $lto;
  return { file    => $str, mtime => $mtime };
}

sub parse_json {
  my ($json) = @_;
  ocache($json, sub { $JSON->decode($_[0]) });
}

sub parse_xml {
  my ($xml) = @_;
  ocache($xml, sub { XML::XPath->new(xml => $_[0]) });
}

sub parse_html {
  my ($html) = @_;
  ocache($html, sub {
    XML::XPath->new(xml => HTML::TreeBuilder->new_from_content($_[0])->as_XML)
  });
}

sub ocache {
  my ($tree, $gen) = @_;
  $ocache{md5_base64(encode('utf-8', $tree))} ||= $gen->($tree);
}
