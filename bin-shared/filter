#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use utf8;

my $filtgrep = $ENV{FILTER_GREP} || 'unset';

my $prog = basename($0);
my %opt;
getopts('hg:', \%opt);
usage() if $opt{h} || !@ARGV;
sub usage {
  die <<EOU;
usage: $prog [-g grep-cmd] cmd [args]
       -g: grep command to use; default is value of \$FILTER_GREP env 
           var (currently: $filtgrep) followed by "grep"
           useful alternatives are:
           pcregrep, egrep, fgrep (must accept -v flag to invert)
EOU
}

my @cmds  = ([@ARGV]);
my $pager = [$ENV{PAGER} || 'less'];
my $grep  = $opt{g} || $ENV{FILTER_GREP} || 'grep';
my (@include, @exclude);

$| = 1;

while (1) {
  # interactive paging view
  system(join('|', map { join(' ', map { quotemeta } @$_) } @cmds, $pager));

  # command prompt reading
  while (1) {
    print "$prog> ";
    my $filt = <STDIN>;
    chomp($filt);

    # quit
    if ($filt =~ /^\s*q/i) {
      # TODO: better output
      use Data::Dumper; print Dumper \@cmds;
      exit;
    }
    # enhance filter
    elsif ($filt =~ /^\s*([ix])\s+(.+)/i) {
      my ($type, $pat) = ($1, $2);
      if ($type eq 'i') {
        push(@include, $pat);
      }
      else {
        push(@exclude, $pat);
      }
      @cmds = ([@ARGV]);
      # TODO: try to merge these into a single regexp?  requires knowledge
      # of regexp engine...
      push(@cmds, [ $grep,       $_ ]) for @include;
      push(@cmds, [ $grep, '-v', $_ ]) for @exclude;
      last;
    }
    # list filters
    elsif ($filt =~ /^\s*l/i) {
      my $n;
      print(++$n, " i $_\n") for @include;
      print(++$n, " i $_\n") for @exclude;
    }
    # delete filter
    elsif ($filt =~ /^\s*d\s+(\d+)/i) {
      die 'not yet implemented';
    }
    # view results
    elsif ($filt =~ /^\s*v/i) {
      last;
    }
    # file output
    elsif ($filt =~ /^\s*o\s+(.+)/i) {
      system(join('|', map { join(' ', map { quotemeta } @$_) } @cmds)
        . ' > ' . quotemeta($1)) && die "$prog: output failed\n";
      print "output written to $1\n";
    }
    # help
    else {
      print <<'EOF';
commands:
i <pattern>: include only lines matching given pattern
x <pattern>: exclude all lines matching given pattern
o <file>: write results of filtering to given file
l: list current filters
v: view output again
d <n>: delete given numbered filter
q: write current filter pipeline and exit
EOF
    }
  }
}
