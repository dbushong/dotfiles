#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;
use File::Basename;
use utf8;

my $filtgrep = $ENV{FILTER_GREP} || 'unset';

my $prog = basename($0);
my %opt;
getopts('hg:', \%opt);
usage() if $opt{h} || !@ARGV;
sub usage {
  die <<EOU;
usage: $prog [-g grep-cmd] cmd [args]
       -g: grep command to use; default is value of \$FILTER_GREP env 
           var (currently: $filtgrep) followed by "grep"
           useful alternatives are:
           pcregrep, egrep, fgrep (must accept -v flag to invert and -e flag
           for expression)
EOU
}

my @cmds  = ([@ARGV]);
my $pager = [$ENV{PAGER} || 'less'];
my $grep  = $opt{g} || $ENV{FILTER_GREP} || 'grep';
my (@include, @exclude);

$| = 1;

while (1) {
  # interactive paging view
  system(join('|', map { join(' ', map { quotemeta } @$_) } @cmds, $pager))
    || die "$prog: command failed\n";

  # command prompt reading
  READ:
  while (1) {
    print "$prog> ";
    my $filt = <STDIN>;
    exit unless defined $filt;
    chomp($filt);

    # quit
    if ($filt =~ /^\s*q/i) {
      print(join(' | ', map { join(' ', map { squote($_) } @$_) } @cmds), "\n");
      exit;
    }
    # enhance filter
    elsif ($filt =~ /^\s*([ix])\s+(.+)/i) {
      my ($type, $pat) = ($1, $2);
      if ($type eq 'i') {
        push(@include, $pat);
      }
      else {
        push(@exclude, $pat);
      }
      rebuild_cmds();
      last;
    }
    # list filters
    elsif ($filt =~ /^\s*l/i) {
      my $n;
      printf("%2d) i %s\n", ++$n, $_) for @include;
      printf("%2d) x %s\n", ++$n, $_) for @exclude;
    }
    # delete filter
    elsif ($filt =~ /^\s*d\s+(\d+)/i) {
      my $del = $1;
      my $n;
      for my $set (\@include, \@exclude) {
        my $i = 0;
        for (@$set) {
          if (++$n == $del) {
            splice(@$set, $i, 1);
            rebuild_cmds();
            last READ;
          }
          $i++;
        }
      }
      print "no such filter number $del\n";
    }
    # view results
    elsif ($filt =~ /^\s*v/i) {
      last;
    }
    # file output
    elsif ($filt =~ /^\s*o\s+(.+)/i) {
      system(join('|', map { join(' ', map { quotemeta } @$_) } @cmds)
        . ' > ' . quotemeta($1)) && die "$prog: output failed\n";
      print "output written to $1\n";
    }
    # help
    else {
      print <<'EOF';
commands:
i <pattern>: include only lines matching given pattern
x <pattern>: exclude all lines matching given pattern
o <file>: write results of filtering to given file
l: list current filters
v: view output again
d <n>: delete given numbered filter
q: write current filter pipeline and exit
EOF
    }
  }
}

sub squote {
  my ($str) = @_;
  return $str unless $str =~ /['"`~!#\$^&*()={}[]|\\;<>?\s]/;
  $str =~ s,\\,\\\\,g;
  $str =~ s/'/'\\''/g;
  "'$str'";
}

sub rebuild_cmds {
  @cmds = ([@ARGV]);
  # TODO: try to merge these into a single regexp?  requires knowledge
  # of regexp engine...
  push(@cmds, [ $grep,  '-e', $_ ]) for @include;
  push(@cmds, [ $grep, '-ve', $_ ]) for @exclude;
}
